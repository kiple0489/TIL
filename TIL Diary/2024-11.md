# 2024.11

## 11/11
최근 DP 문제들만 풀어보려는 경향이 생기다 보니 문제풀이의 텀이 길어지는 것 같은 느낌이 들었다. 그래서 오늘까지만 DP 문제를 풀어보고 여유가 부족할 때는 간단한 문제들도 풀어보면서 TIL을 하는 습관을 늘려나가기로 생각했다. 그리고 모든 문제들을 리뷰하기엔 비효율 적이라는 생각도 들어 인상깊었던 문제들 위주로 TIL 다이어리를 작성하면 좋겠다는 생각또한 하였다. 11월에 처음 풀어본 문제는 백준의 2293 문제로 동전을 이용한 DP 문제였다.

    n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.

    사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.

 이 문제에 해결방법을 생각해 보았고, **n*k** 크기의 배열을 만들어 **k= 0** 일때부터 이전에 만들 수 있는 경우의 개수를 탐색해서 더해가는 방법으로 구현을 하였다. 

``` python
for j in range(1, k+1):
    for i in range(n):
        
        if coins[i] > j:
            index = 0
        else:
            index = j-coins[i]
        
        for c in range(i, n):
            dp[i][j] += dp[c][index]
```

 하지만 제출하였을 때, 처음으로 메모리 초과로 인해 문제를 실패하였고 다시 문제를 확인하니 4MB라는 메모리 제한이 있다는걸 확인하였다. **n은** 최대 100, **k**는 최대 10000 이므로 **4Byte** 자료형인 int를 사용하여 DP 리스트로 만들면 최대 크기가 4MB를 넘기게 되었다. 따라서 DP 리스트를 만들려면 1차원으로 만들어야 가능했다.

 DP를 1차원으로 만들었을 때, 인덱스를 0 부터 k까지 늘려가며 이전 값을 참조하여 값을 도출하려고 하니 해결책이 생기지 않았다. 그래서 k를 늘려가며 DP를 채우는 것이 아닌 n을 늘려가며 dp를 업데이트를 하는 방향으로 아이디어를 생각해야했다. 그래서 동전의 종류를 하나씩 추가해가며 현재 인덱스 - 코인값에 위치한 dp값이 존재한다면 그 값만큼 더해주면 마지막 동전까지 dp를 계산한다면 원하는 결과를 얻을 수 있겠다는 생각으로 코드를 구현하였고 문제를 통과할 수 있었다.

``` python
 n, k = map(int, input().split())

coins = []
for _ in range(n):
    coins.append(int(input()))

dp = [0 for _ in range(k+1)]
dp[0] = 1

for coin in coins:
    for i in range(coin, k+1):
        dp[i] += dp[i-coin]


print(dp[k])
```

DP 문제를 풀수록 문제를 해결하기 위해 생각하는 폭이 넓어지는 것 같아 좋지만 다른 문제들에 비해 난이도와 생각하는 시간이 걸리다보니 자주는 풀기 힘들어지는 것 같다. 앞으로 이런 벨런스를 조정해나가야겠다.