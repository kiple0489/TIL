# 2024.10

## 10/1
다시 처음부터 시작하자는 마음가짐으로 깃허브에 TIL을 시작하였다. 알고리즘 풀이를 시작으로 꾸준히 TIL을 작성하는 것을 목표로 하고있다.

작년에 취업을 하고 약 1년 간 C언어 베이스의 C++을 사용하며 임베디드 컴퓨팅 코드에 익숙해졌지만 여전히 알고리즘을 통한 문제 해결은 Python이 익숙하게 느껴져 Python과 C++ 두가지 언어을 모두 사용하고자 한다. 

알고리즘의 가장 중요한 포인트는 **시간**과 **공간**이다. 

같은 문제를 풀 때, 어떻게 더 적은 메모리 공간을 사용해서 더 짧은 시간에 문제를 해결할 수 있을지 탐구하는 것이 알고리즘의 본질이다. 가장 효율적인 자료 구조를 사용하고 가장 효율적인 탐색 방법, 추가, 수정, 삭제 방법을 탐구하며 문제를 해결했을 때의 성취감을 바로 느낄 수 있는게 알고리즘 풀이의 재미라고 생각한다.

첫날 가볍게 문제풀이로 시작한 문제는 백준 1439번 뒤집기 문제다.

    솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.  

    예를 들어 S=0001100 일 때, 전체를 뒤집으면 1110011이 된다.

    4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다. 하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.  

    문자열 S가 주어졌을 때, 다솜이가 해야하는 행동의 최소 횟수를 출력하시오.


그리디 문제는 직관적으로 풀 수 있는 문제라 가볍게 접근할 수가 있는게 장점이다. 간단하게 오셀로 같은 게임이라 생각이 들었고 연속된 숫자들을 한 덩이로 묶었을 때, 가장 적은 덩이의 수만큼 뒤집으면 되는 문제였다.

숫자가 바뀌는 것을 체크하기 위해 **curNum**이라는 변수를 사용하였고 1과 0의 덩이 수를 체크하기 위한 변수 **zeroNum**과 **oneNum**을 사용하였다.


    curNum, zeroNum, oneNum = -1, 0, 0
    str = input()

    for i in str:
        n = int(i)
        
        if n != curNum:
            curNum = n;
            
            if n == 1:
                oneNum += 1
            else:
                zeroNum += 1

    print(min(zeroNum, oneNum))


첫 날은 가볍게 그리디 문제로 시작하였고 계속해서 다양한 문제들을 풀어보며 다시 알고리즘의 감을 되살리고자 한다.
