# 2024.10

## 10/1
다시 처음부터 시작하자는 마음가짐으로 깃허브에 TIL을 시작하였다. 알고리즘 풀이를 시작으로 꾸준히 TIL을 작성하는 것을 목표로 하고있다.

작년에 취업을 하고 약 1년 간 C언어 베이스의 C++을 사용하며 임베디드 컴퓨팅 코드에 익숙해졌지만 여전히 알고리즘을 통한 문제 해결은 Python이 익숙하게 느껴져 Python과 C++ 두가지 언어을 모두 사용하고자 한다. 

알고리즘의 가장 중요한 포인트는 **시간**과 **공간**이다. 

같은 문제를 풀 때, 어떻게 더 적은 메모리 공간을 사용해서 더 짧은 시간에 문제를 해결할 수 있을지 탐구하는 것이 알고리즘의 본질이다. 가장 효율적인 자료 구조를 사용하고 가장 효율적인 탐색 방법, 추가, 수정, 삭제 방법을 탐구하며 문제를 해결했을 때의 성취감을 바로 느낄 수 있는게 알고리즘 풀이의 재미라고 생각한다.

첫날 가볍게 문제풀이로 시작한 문제는 백준 1439번 뒤집기 문제다.

    솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.  

    예를 들어 S=0001100 일 때, 전체를 뒤집으면 1110011이 된다.

    4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다. 하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.  

    문자열 S가 주어졌을 때, 다솜이가 해야하는 행동의 최소 횟수를 출력하시오.


그리디 문제는 직관적으로 풀 수 있는 문제라 가볍게 접근할 수가 있는게 장점이다. 간단하게 오셀로 같은 게임이라 생각이 들었고 연속된 숫자들을 한 덩이로 묶었을 때, 가장 적은 덩이의 수만큼 뒤집으면 되는 문제였다.

숫자가 바뀌는 것을 체크하기 위해 **curNum**이라는 변수를 사용하였고 1과 0의 덩이 수를 체크하기 위한 변수 **zeroNum**과 **oneNum**을 사용하였다.

``` python
curNum, zeroNum, oneNum = -1, 0, 0
str = input()

for i in str:
    n = int(i)
    
    if n != curNum:
        curNum = n;
        
        if n == 1:
            oneNum += 1
        else:
            zeroNum += 1

print(min(zeroNum, oneNum))
```

첫 날은 가볍게 그리디 문제로 시작하였고 계속해서 다양한 문제들을 풀어보며 다시 알고리즘의 감을 되살리고자 한다.

## 10/2
오늘은 알고리즘 문제의 꽃 DP 문제를 풀어보았다. DP는 **Dynamic Programming**의 약자로 처음 해당 용어를 만든 리처드 벨만이 DP라는 이름을 붙인 이유는 단지 '멋있어서'라고 한다. 그래도 DP로 문제를 해결해 나가는 과정은 실제로 dynmaic하기 때문에 어울리는 이름이라고 한다.

DP의 가장 기초적인 아이디어는 공간을 활용하여 시간적 효율을 극대화 하는 것이라 생각한다. DP를 활용하는 문제들의 대부분은 Greedy하게 해결이 가능하다. 하지만 문제의 스케일이 커질수록 계산해야 하는 양이 시간 복잡도로 인해 지수적으로 증가하기 때문에 원하는 시간내에 문제 해결이 불가능해진다.

DP는 이를 약간의 메모리 공간을 더 활용하여 해결한다. 결과값을 출력하기 위해 아랫 단계부터 최종 값까지 단계를 밟아가며 최적의 값을 메모리에 저장해나간다. 이렇게 저장되는 데이터는 불필요한 반복적인 계산 과정을 생략시켜 매우 큰 시간적 효율을 가져올 수 있다. 이때 사용되는 메모리는 보통 문제의 크기에 따라 동적으로 할당하며 이러한 점이 dynamic한 programming이란 이름과 어울린다고 생각한다.

따라서 DP를 활용하기 위해선 결과값을 도출하기 위해 어떤 데이터를 저장해 나갈 것인가를 파악해야 하는데 이를 찾아내는 것이 프로그래밍 실력이라고 할 수 있다. 이러한 실력은 DP 문제를 자주 풀며 키워나가야 하는데 오랜만에 DP 감각을 살리기 위해 적당한 난이도의 문제들을 풀어보았다.

먼저 파이썬으로 풀어본 문제는 백준 1932번 문제 정수 삼각형이다.

            7
          3   8
        8   1   0
      2   7   4   4
    4   5   2   6   5
    
    위 그림은 크기가 5인 정수 삼각형의 한 모습이다.

    맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.

    첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.

문제를 그리디하게 풀고자 한다면 모든 경우의 수를 찾으며 O(n^n)의 시간 복잡도가 걸리게 된다. 하지만 2차원 배열의 공간을 사용하여 오른쪽 위와 왼쪽 위에서 온 최대의 값을 판단하여 저장한다면 2중 for문을 사용하여 간단하게 O(n^2)의 시간 복잡도로 해결이 가능해진다.

입력받은 숫자들을 **numList**에 저장하고 중간 과정의 결과들을 저장하기 위한 배열 **dp**를 선언하였다. **dp[i][j]** 에 저장되는 값은 대각선 좌우 위쪽의 값 중 더 큰 값과 **numList[i][j]** 의 합으로 계산 도중 배열의 범위를 벗어나지 않기 위한 노력만 조금 추가해서 쉽게 문제를 해결하였다.
``` python
n = int(input())

dp = [[0 for _ in range(i)] for i in range(1, n+1)]
numList = []

for _ in range(n):
    nums = list(map(int, input().split()))
    numList.append(nums)

for i in range(n):
    for j in range(i+1):
        x = max(0, i-1)
        y = max(0, j-1)
        z = min(x, j)

        dp[i][j] = numList[i][j] + max(dp[x][y], dp[x][z])

print(max(dp[n-1]))
``` 
모처럼의 여유있는 휴일이라 C++로 다른 DP 문제인 백준 11057 오르막 수 문제를 풀어보았다.

    오르막 수는 수의 자리가 오름차순을 이루는 수를 말한다. 이때, 인접한 수가 같아도 오름차순으로 친다. 예를 들어, 2234와 3678, 11119는 오르막 수이지만, 2232, 3676, 91111은 오르막 수가 아니다.

    수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 프로그램을 작성하시오. 수는 0으로 시작할 수 있다.

    첫째 줄에 길이가 N인 오르막 수의 개수를 10,007로 나눈 나머지를 출력한다.

해당 문제는 N이 2일 때의 결과를 보고 어느 정도의 직관을 얻을 수 있었다. N = 2일 때의 답은 55로 1부터 10의 합과 같다. 여기서 아이디어를 얻어 이차원 배열 **dp**를 만들어 가능한 오르막 수를 더해가는 코드를 설계했다.

아래 표처럼 0부터 9까지 1자리부터 시작해서 가능한 오르막 수를 더해간다면 9칸에 해당 N일때의 결과 값을 얻을 수 있다.

0|1|2|3|4|5|6|7|8|9
---|---|---|---|---|---|---|---|---|---|
1|2|3|4|5|6|7|8|9|10
10|19|27|34|40|45|49|52|54|55
55|||||...||||

해당 표를 기반으로 **dp**배열에 저장할 값을 계산하였고 길이가 N일 때의 결과값은 **dp[N-1][9]** 에 있으며 다음 자리로 넘어갈 때, **dp[N][0]** 에 해당 결과 값을 넣을 수 있다.

    dp[i][j] = dp[i][j-1] + dp[i][0] - dp[i-1][j-1];

하지만 해당 풀이로 문제를 바로 통과하지 못했고 이유를 분석해야했다. 원인은 **10007**의 나머지를 출력해야 하는점 떄문이었다.  N이 클 때, **long long** 자료형으로도 값을 담아내지 못하였고 **dp**에 값을 저장할 때, 나머지 값을 저장해야 했다. 

나눗셈을 저장하는 모듈러스 계산은 덧셈과 뺄셈에 닫혀있기 때문에 나머지로 저장을 해도 되지만 실제 프로그램에서의 나머지를 얻는 %를 통한 계산은 음수에서 모듈러스와는 다르게 적용되기 때문에 다음과 같이 약간의 수정이 필요하였다.

    dp[i][j] = mod + dp[i][j-1] + dp[i][0] - dp[i-1][j-1];
    dp[i][j] %= mod;

아이디어를 수정하고 다시 제출하여 문제를 해결할 수 있었다.
``` c++
#include <iostream>

using namespace std;

int main()
{
    int mod = 10007;
    int n;
    cin >> n;

    int dp[1001][10] = {0,};

    for (int j = 0; j < 10; j++)
    {
        dp[0][j] = j+1;
    }

    for (int i = 1; i < n; i++)
    {
        dp[i][0] = dp[i-1][9];

        for (int j = 1; j < 10; j++)
        {
            dp[i][j] = mod + dp[i][j-1] + dp[i][0] - dp[i-1][j-1];
            dp[i][j] %= mod;
        }
    }

    cout << dp[n-1][9] % mod;
    
    return 0;
}
```
오랜만에 DP와 함께 잊고 지냈던 모듈러스 계산 또한 떠올릴 수 있는 시간이 되었던 것 같다. 다음에는 그래프나 탐색과 관련된 문제들도 풀어보면 좋을 것 같다.